import asyncio
import json
import logging
import random
import string
import subprocess
from datetime import datetime, timedelta
from typing import List

import api.model.checker as m_checker
import api.model.exploit_model as m_exploit
import api.model.machine as m_machine
import api.repository.checker.adapters.exploit_service as exploit_checker
import api.repository.exploit.adapters.watcher as exploits_watcher
import api.repository.exploit.exploit as exploits
import api.repository.machine.adapters.exploit as exploit_machine
from api.misc import with_redis

WATCHER_EVERY_X_SECONDS = 2
FLAGS_N = 5
LIMIT_HANDLE = 3  # Сколько обрабатывать эксплоитов за раз
CHECK_STATE_TIMEOUT = timedelta(minutes=4)
STATE_TIMEOUT = timedelta(minutes=10)
REDIS_EXPIRE = timedelta(minutes=20)
VULN_ID = "0"  # TODO
EXPLOIT_RUNNER_IMAGE = "exploit-runner"

logging.basicConfig(level=logging.INFO)


def handle_starting(exploit_run_id: int):
    mach = exploit_machine.get_machine(exploit_run_id)

    if mach is None:
        logging.info(f"starting machine for {exploit_run_id=}")
        exploit_machine.start_machine(exploit_run_id)
        return

    if mach is not None:
        match mach.state:
            case m_machine.MachineState.on:
                exploits_watcher.set_exploit_run_state(
                    exploit_run_id, m_exploit.ExploitStatus.waiting_for_machine
                )
            case m_machine.MachineState.off:
                exploit_machine.delete_machine(exploit_run_id)
            case _:
                return  # wait untill it becames on


timing_fmt = "state_timing/exploit_run:{run_id}/state:{state}"
time_fmt = "%Y-%m-%d %H:%M:%S"


@with_redis
def set_timing(r, exploit_run_id: int, state: m_exploit.ExploitStatus):
    key = timing_fmt.format(run_id=exploit_run_id, state=state)
    r.setex(key, REDIS_EXPIRE, datetime.strftime(datetime.now(), time_fmt))


@with_redis
def get_since_state_started(
    r, exploit_run_id: int, state: m_exploit.ExploitStatus
) -> timedelta | None:
    now = datetime.now()
    key = timing_fmt.format(run_id=exploit_run_id, state=state)

    start_time_raw = r.get(key)
    if start_time_raw is None:
        return None

    start_time = datetime.strptime(start_time_raw.decode(), time_fmt)

    return now - start_time


def handle_waiting_for_machine(exploit_run_id: int):
    since_started = get_since_state_started(
        exploit_run_id, m_exploit.ExploitStatus.waiting_for_machine
    )
    if since_started is None:
        set_timing(exploit_run_id, m_exploit.ExploitStatus.waiting_for_machine)
    elif since_started > CHECK_STATE_TIMEOUT:
        exploits_watcher.set_exploit_run_result(
            exploit_run_id, m_exploit.ExploitResult.machine_start_timeout
        )
        exploits_watcher.set_exploit_run_state(
            exploit_run_id, m_exploit.ExploitStatus.to_delete_machine
        )
        return

    checker_runs = exploit_checker.check_results(exploit_run_id)
    assert len(checker_runs) != 0

    success = any([run[1] is not None and run[1].ok for run in checker_runs])
    if success:
        exploits_watcher.set_exploit_run_state(
            exploit_run_id, m_exploit.ExploitStatus.sending_flags
        )
        return

    have_in_progress = any(
        [
            run[0] is not None and run[0] == m_checker.CheckStatus.in_progress
            for run in checker_runs
        ]
    )
    if not have_in_progress:
        exploit_checker.check_start(
            exploit_run_id
        )  # todo add some throttling like in demo_watcher mb


fmt_flags = "flags/exploit_run_id:{run_id}"


@with_redis
def get_flags(r, exploit_run_id: int) -> List[str] | None:
    key = fmt_flags.format(run_id=exploit_run_id)
    flags_raw = r.get(key)
    if flags_raw is None:
        return None

    return json.loads(flags_raw)


@with_redis
def set_flags(r, exploit_run_id: int, flags: List[str]):
    key = fmt_flags.format(run_id=exploit_run_id)
    r.setex(key, REDIS_EXPIRE, json.dumps(flags))


# todo secrets :D


def generate_flag_id() -> str:
    alph = string.ascii_uppercase
    return "".join(random.choices(alph, k=31)) + "="


def generate_flag() -> str:
    alph = string.ascii_uppercase
    return "".join(random.choices(alph, k=31)) + "="


def handle_sending_flags(exploit_run_id: int):
    since_started = get_since_state_started(
        exploit_run_id, m_exploit.ExploitStatus.sending_flags
    )
    if since_started is None:
        set_timing(exploit_run_id, m_exploit.ExploitStatus.sending_flags)
    elif since_started > STATE_TIMEOUT:
        exploits_watcher.set_exploit_run_result(
            exploit_run_id, m_exploit.ExploitResult.other_checker_fail
        )
        exploits_watcher.set_exploit_run_state(
            exploit_run_id, m_exploit.ExploitStatus.to_delete_machine
        )
        return

    flags = get_flags(exploit_run_id)
    if flags is None:
        flags = [generate_flag() for _ in range(FLAGS_N)]
        for flag in flags:
            exploit_checker.put_start(exploit_run_id, flag, VULN_ID, generate_flag_id())
        set_flags(exploit_run_id, flags)

    flags_success = []

    for flag in flags:
        put_status, put_result = exploit_checker.get_flag_put(exploit_run_id, flag)
        logging.info(f"{flag=} {put_status=} {put_result=}")

        if put_result is None or put_result.ok is None:
            continue

        if not put_result.ok:
            exploits_watcher.set_exploit_run_result(
                exploit_run_id, m_exploit.ExploitResult.other_checker_fail
            )
            exploits_watcher.set_exploit_run_state(
                exploit_run_id, m_exploit.ExploitStatus.to_delete_machine
            )
            continue

        flag_id = put_result.results[0].comment if len(put_result.results) > 0 else ""
        # if flag_id is None:
        # logging.error(f"flag id is NONE, {flag=} {put_status=} {put_result=}")

        get_status, get_result = exploit_checker.get_flag_get(exploit_run_id, flag)
        if get_status is None:
            exploit_checker.get_start(exploit_run_id, flag_id, flag, VULN_ID)

        if get_result is None or get_result.ok is None:
            continue

        if not get_result.ok:
            exploits_watcher.set_exploit_run_result(
                exploit_run_id, m_exploit.ExploitResult.other_checker_fail
            )
            exploits_watcher.set_exploit_run_state(
                exploit_run_id, m_exploit.ExploitStatus.to_delete_machine
            )
            continue

        flags_success.append(flag)

    if set(flags_success) == set(flags):
        exploits_watcher.set_exploit_run_state(
            exploit_run_id, m_exploit.ExploitStatus.running
        )


def handle_running(exploit_run_id: int):
    expl = exploits.get_exploit_by_run_id(exploit_run_id)
    if expl is None:
        raise ValueError("no such exploit")

    mach = exploit_machine.get_machine(exploit_run_id)
    if mach is None:
        raise ValueError("no such machine")  # todo just move to waiting of machine

    if mach.hostname is None:
        raise ValueError("machine is down")  # same

    cmd = [
        "docker",
        "run",
        "-v",
        expl.exploit_path + ":/e.py",
        EXPLOIT_RUNNER_IMAGE,
        "python3",
        "/e.py",
        mach.hostname,
    ]
    logging.debug(f"{cmd=}")
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    proc.wait()

    res = str(proc.stdout.read().decode())

    result_success = False
    for flag in get_flags(exploit_run_id):
        if flag in res:
            result_success = True

    if result_success:
        exploits_watcher.set_exploit_run_result(
            exploit_run_id, m_exploit.ExploitResult.ok
        )
    else:
        exploits_watcher.set_exploit_run_result(
            exploit_run_id, m_exploit.ExploitResult.no_flags
        )

    exploits_watcher.set_exploit_run_state(
        exploit_run_id, m_exploit.ExploitStatus.to_delete_machine
    )


async def run_all_exploits():
    exploits = exploits_watcher.get_running_exploits(LIMIT_HANDLE)

    logging.info(f"handling {exploits=}")

    for exploit_run_id in exploits:
        logging.info(f"exploit id = {exploit_run_id}, state {exploits[exploit_run_id]}")
        match exploits[exploit_run_id]:
            case None:
                exploits_watcher.set_exploit_run_state(
                    exploit_run_id, m_exploit.ExploitStatus.starting
                )

            case m_exploit.ExploitStatus.starting:
                handle_starting(exploit_run_id)

            case m_exploit.ExploitStatus.waiting_for_machine:
                handle_waiting_for_machine(exploit_run_id)

            case m_exploit.ExploitStatus.sending_flags:
                handle_sending_flags(exploit_run_id)

            case m_exploit.ExploitStatus.running:
                handle_running(exploit_run_id)

            case m_exploit.ExploitStatus.to_delete_machine:
                mach = exploit_machine.get_machine(exploit_run_id)
                if mach is None:
                    exploits_watcher.set_exploit_run_state(
                        exploit_run_id, m_exploit.ExploitStatus.checked
                    )
                    continue

                exploit_machine.delete_machine(exploit_run_id)
            case _:
                raise ValueError(
                    "unhanlded exploit state: " + str(exploits[exploit_run_id])
                )


async def scheduler():
    while True:
        await run_all_exploits()
        await asyncio.sleep(WATCHER_EVERY_X_SECONDS)


async def main():
    task = asyncio.create_task(scheduler())
    await task
